## **Δημιουργία ΒΔ (CREATE DATABASE)**

Δημιουργεί μία καινούργια ΒΔ με όνομα το όνομα_ΒΔ.

```
CREATE DATABASE όνομα_ΒΔ
```

## **ΔιαγραφήΒΔ(DROP DATABASE)**

Διαγράφει τη ΒΔ με όνομα το όνομα_ΒΔ.

```
DROP DATABASE όνομα_ΒΔ
```

## **Δημιουργία πίνακα(CREATE TABLE)**

Δημιουργεί ένα καινούργιο πίνακα με όνομα το όνομα_πίνακα.

```
CREATE TABLE όνομα_πίνακα (
όνομα_πεδίου τύπος_πεδίου επιπλέον_επιλογές,
....,
[περιορισμοί],
....
)
```
όπου οι επιπλέον_επιλογές και οι περιορισμοί είναι προαιρετικά, ενώ μπορεί να έχουμε πολλαπλές δηλώσεις πεδίων και περιορισμών.

## **Πεδία**

H SQL υποστηρίζει πληθώρα τύπωνπεδίωνγια αριθμούς, αλφαριθμητικά, ημ/νίες, χρόνο
κλπ. Οι βασικοί τύποιείναι οι εξής:

**CHAR(Χ):** Αλφαριθμητικό σταθερού μεγέθους Χ.

**VARCHAR(Χ):** Αλφαριθμητικό μεταβλητού μεγέθους Χ.

**TINYINT:** Ακέραιος μεγέθους 1 byte.

**SMALLINT:** Ακέραιος μεγέθους 2 bytes.

**MEDIUMINT:** Ακέραιος μεγέθους 3 bytes.

**INT:** Ακέραιος μεγέθους 4 bytes.

**BIGINT:** Ακέραιος μεγέθους 8 bytes.

**FLOAT:** Δεκαδικός μεγέθους 4 bytes.

**DOUBLE:** Δεκαδικός μεγέθους 8 bytes.

**DATE:** Ημ/νια στη μορφή ‘YYYY-MM-DD’, πχ., ‘2014- 01 - 31’.

**TIME:** Ώρα στη μορφή ‘ΗΗ:MM:SS’, π.χ., ‘12:30:00’ αντιστοιχεί στις 12 και μισή το μέσημέρι.

**TIMESTAMP:** Ημ/νια και ώρα μαζί πχ., ‘2014- 01 - 31 12:30:00’.

Για παράδειγμα για να δημιουργήσω τον πίνακα Customer μια πρώτη προσπάθεια θα ήταν να γράψουμε το εξής:

```
CREATE TABLE Customer (  
cid INT,  
afm CHAR(10),  
address VARCHAR(50),  
name CHAR(20),  
sname CHAR(20),  
dateOfBirth DATE  
);
```

## **Επιπλέον_επιλογές**

Οι κυριότερες επιπλέον_επιλογές που υπάρχουν στη σύνταξη της CREATE TABLE,
επιγραμματικά οι είναι οι εξής:

**NOT NULL:** Δηλώνει ότι το πεδίο πρέπει να έχει υποχρεωτικά τιμή.

**DEFAULT:** Δηλώνει την προκαθορισμένη τιμή ενός πεδίου αν δεν έχει περαστεί τιμή.

**UNIQUE [KEY]:** Δηλώνει εναλλακτικό κλειδί (το ΚΕΥ προαιρετικό).Εναλλακτικό κλειδί είναι ένα πεδίο το οποίο παίρνει μοναδικές τιμές και θα μπορούσε υπο άλλες συνθήκες να θεωρηθεί και πρωτεύον κλειδί.

**[PRIMARY] KEY:** Δηλώνει πρωτεύον κλειδί (το PRIMARY είναι προαιρετικό αλλά καλό είναι να γράφεται για λόγους αναγνωσιμότητας).

**AUTO_INCREMENT:** Δηλώνει ότι το πεδίο θα παίρνει τιμές αυτόματα. Στην MySQL μπορεί να υπάρχει μόνο ένα πεδίο σε κάθε πίνακα με αυτή την επιλογή. Η αυτόματη εκχώρηση τιμής γίνεται προσθέτοντας +1 στην προηγούμενη που εκχωρήθηκε.

Λαμβάνοντας υπόψη τα παραπάνω επανερχόμαστε με το νέο ορισμό πίνακα ως εξής:

```
CREATE TABLE Customer (  
cid INT AUTO_INCREMENT **PRIMARY KEY** ,  
afm CHAR(10) **UNIQUE KEY** ,  
address VARCHAR(50) DEFAULT ‘Unknown’,  
name CHAR(20) NOT NULL DEFAULT ‘Unknown’,  
sname CHAR(20) NOT NULL DEFAULT ‘Unknown’,  
dateOfBirthDATEDEFAULTNULL  
);
```

Εναλλακτικά Η δήλωση του πίνακα Customer έχει ως ακολούθως:

```
CREATE TABLE Customer (

cid INT AUTO_INCREMENT,

afm CHAR(10),

address VARCHAR(50) DEFAULT ‘Unknown’,

name CHAR(20) NOT NULL DEFAULT ‘Unknown’,

sname CHAR(20) NOT NULL DEFAULT ‘Unknown’,

dateOfBirth DATE DEFAULT NULL,

**PRIMARY KEY** (cid),

**UNIQUEKEY** (afm)

);
```

**Σύνθετο κλειδί**

Ας υποθέσουμε ότι έχουμε τον πίνακα με σύνθετο πρωτεύον κλειδί τα πεδία cid και pnum.
Το pnum περιέχει τον τηλεφωνικό αριθμό του πελάτη. Το cid προέρχεται από τον πίνακα
Customer και θα είναι το ξένο κλειδί το οποίο θα συνδέει τους δύο πίνακες.

Για να δηλώσουμε περισσότερα από ένα πεδία ως πρωτεύον κλειδί (σύνθετο κλειδί) απλώς
χωρίζουμε τα πεδία με κόμμα.

Η δήλωση του πίνακα θα γίνει ως εξής:
```
CREATE TABLE Phones (

cid INT,

pnum CHAR(10),

PRIMARY KEY (cid, pnum)

);
```

**Ξένοκλειδί(FOREIGN KEY ... REFERENCES ...)**

Κατά τη σύνδεση των δυο πινάκων δημιουργούνται τα εξής ερωτήματα. Πρώτον τι θα πρέπει

να γίνει σε περίπτωση που κάποια εγγραφή στον πίνακα Customerαλλάξει τιμή στο

πρωτεύον κλειδί του πίνακαPhonesκαι δεύτερον τί θα πρέπει να συμβεί αν μια εγγραφή

στον πίνακαCustomerδιαγραφεί.

Για παράδειγμα, έστω ότι ο πίνακας Phones έχει την εγγραφή <1, 6911222333>. Το ερώτημα

είναι τι θα πρέπει να συμβεί αν στον πίνακα Customer αλλάξει η εγγραφή με cid 1 από 1 πχ.,


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
σε 30. Η εγγραφή <1, 6911222333> στο Phones παραβιάζει τώρα τους περιορισμούς

αναφορικής ακεραιότητας καθώς πλέον δεν υπάρχει εγγραφή στο Customer με cid 1.

Για να καθορίσουμε τι επιθυμούμε να συμβεί σε περίπτωση αλλαγής ή διαγραφής μιας

εγγραφής χρησιμοποιούμε τη δήλωση ξένου κλειδιού.

Η δήλωση γίνεται με την εντολή:

```
FOREIGN KEY (πεδία) REFERENCES όνομα_πίνακα (πεδία αναφοράς)
```
Στο παράδειγμά μας γράφω:

FOREIGN KEY (cid) REFERENCES Customer (cid)

Αξίζει να σημειωθεί ότι το όνομα του ξένου κλειδιού και του κλειδιού στο οποίοαναφέρεται
δε χρειάζεταινα συμπίπτουν. Υποχρεωτικά όμως πρέπει να είναι ιδίου τύπου.

Επιτρέπεται η δήλωση ξένου κλειδιού που απαρτίζεται από δύο ή περισσότερα πεδία, αρκεί
τα αντίστοιχα πεδία αναφοράς να είναι πρωτεύοντα κλειδιά στον πίνακα που
αναφερόμαστε. Γιαπαράδειγμα ηπαρακάτω δήλωση:

FOREIGNKEY(x,y)REFERENCEST(a,b)

είναι καθόλα επιτρεπτή αρκεί ταxκαιyνα έχουν ίδιους τύπους με ταaκαιbαντίστοιχα, και
ταaκαιbαπό κοινού να απαρτίζουν το πρωτεύον κλειδί του πίνακα Τ.

Για νακαθορίσουμε τι ακριβώς θα συμβεί σε περίπτωση αλλαγής ή διαγραφής μιας
εγγραφήςχρησιμοποιούμεκατάδήλωσητουξένου κλειδιού τις δηλώσεις ON UPDATE και
ON DELETE.

Οι πιθανέςενέργειεςπου υποστηρίζονται είναι οι εξής:

**RESTRICT:** Απαγορεύει τη διαγραφή ή ενημέρωση της εγγραφής.

**CASCADE:** Ενημερώνει ή διαγράφει τις αντίστοιχες εγγραφές.

**SET NULL:** Διατηρεί τις εγγραφές με NULL στα αντίστοιχα πεδία.

**NO ACTION:** Απαγορεύει τη διαγραφή ή ενημέρωση της εγγραφής.

Η σύνταξη της δήλωσης ξένου κλειδιού είναι τελικά η εξής:

FOREIGNKEY(πεδία)REFERENCESόνομα_πίνακα (πεδία αναφοράς)

ON DELETEενέργεια

ON UPDATEενέργεια

Στοπαράδειγμα μας, αν έχω στο Phones την εγγραφή <1, 6911222333> και στο Customer
αλλάξωτην εγγραφή με cid 1 από cid 1 σε 30 τότε θα έχω αναλόγως της ενέργειας:


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
**RESTRICT:** Η αλλαγή από 1 σε 30 στο Customer δε θα πραγματοποιηθεί. Για να γίνει θαπρέπει
πρώτα να διαγραφεί η εγγραφή <1, 6911222333> στο Phones.

**CASCADE:** Η αλλαγή από 1 σε 30 στο Customer θα πραγματοποιηθεί. Η εγγραφή
<1,6911222333> του Phones θα αλλάξει σε <30, 6911222333>.

**SET NULL:** Δεν είναι δυνατόν να οριστεί αυτή η ενέργεια καθώς το cid είναι μέρος του
PRIMARY KEY στον πίνακα Phones και κατ’ επέκταση δεν μπορεί να πάρει NULL τιμές. Αν
επιχειρούσαμε να εισάγουμε FOREIGN KEY με αυτή την ενέργεια θα παίρναμε μήνυμα
λάθους.

Ο τελικός πίνακαςPhonesστο παράδειγμά μας,είναι:

CREATE TABLE Phones (

cid INT,

pnum CHAR(10),

PRIMARY KEY (cid, pnum),

FOREIGN KEY (cid) REFERENCES Customer (cid)

ON DELETE RESTRICT

ON UPDATE CASCADE

);

**Αλλαγή χαρακτηριστικών σε πίνακα(ALTERTABLE)**

Έχοντας ορίσει έναν πίνακα μπορούμε να αλλάξουμε τα χαρακτηριστικά του με την εντολή
ALTERTABLE.

```
ALTER TABLE όνομα_πίνακα είδος_αλλαγής;
```
Ως προς το **είδος_αλλαγής** ξεχωρίζουμε τις εξής τρεις:

**ADD:** Για να προσθέσουμε στον πίνακα.
Κύριες επιτρεπτές προσθέσεις: πεδίο,PRIMARY,UNIQUEήFOREIGNKEY.

**DROP:** Για να αφαιρέσουμε από τον πίνακα.
Κύριες επιτρεπτές αφαιρέσεις: πεδίο,PRIMARY,UNIQUEήFOREIGNKEY.

**CHANGE:** Για να αλλάξουμε τον ορισμό πεδίου.

**ΠαραδείγματαχρήσηςALTERTABLE**

```
 ALTER TABLECustomer DROP name;
Προαιρετικά θα μπορούσε να γραφεί DROP COLUMN name. Διαγράφει το πεδίο name
από τον πίνακα εφόσον δεν παραβιάζεται ξένοκλειδί.
```

```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
```
 ALTER TABLE Phones DROP PRIMARY KEY;
Διαγράφει το πρωτεύον κλειδί στονπίνακα Phones. Το πεδίο που ήτανπρωτεύον κλειδί
(cid) εξακολουθεί να υπάρχει απλά δενορίζεται πλέον σαν πρωτεύον.
```
```
 ALTERTABLECustomerADDCOLUMNnameCHAR(20)NOTNULLDEFAULT'Unknown';
Υποθέτοντας ότι το name είχε σβηστεί από τον πίνακα Customer, το ξαναδημιουργούμε
δίνοντας τη δήλωση του πεδίου όπως θα κάναμε στην CREATE TABLE. Η λέξη COLUMN
στην παραπάνω εντολή είναι προαιρετική. Το πεδίο δημιουργείται και η σειρά που
καταλαμβάνει είναι η τελευταία. Αν θέλαμε να είναι πρώτο στον πίνακα θα μπορούσαμε
νατο είχαμε δημιουργήσει με τηνεντολή: ALTERTABLECustomerADDCOLUMNname
CHAR(20)NOTNULLDEFAULT'Unknown'FIRST; ενώ αν θέλαμε να καταλάμβανεάλλη
σειρά θα δίναμε: ALTERTABLECustomerADDCOLUMNnameCHAR(20)NOTNULL
DEFAULT'Unknown'AFTERaddress;
```
```
 ALTER TABLE Phones ADD PRIMARY KEY (cid);
ΔηλώνειστονπίνακαPhonesότιPRIMARYKEYείναιτοcid.Το/τα πεδία στη δήλωση του
PRIMARY KEY πρέπει ναυπάρχουν στον πίνακα και να μην υπάρχει δηλωμένο άλλο
PRIMARY KEY.
```
**Εισαγωγή τιμών σε ΒΔ (Νέα εγγραφή)(INSERT...INTO...VALUES...)**

```
INSERT επιλογές [INTO] όνομα_πίνακα VALUES (εγγραφή), (εγγραφή),...
```
Για παράδειγμα με την ακόλουθη εντολή εισάγουμε δύο καινούργιες εγγραφές στον πίνακα
Customer(cid,afm,address,name,sname,dateOfBirth).

INSERT INTO Customer VALUES

(1, '077783234', '56Baltetsiou st.', 'Kostas', 'Kostantinou', '1990- 10 - 30'),

(2, '175783239', '107 Diakou st.', 'Eleni', 'Kostantinou', '1985- 11 - 02');

**_Προσοχή:_** Αν και στο σχεσιακό μοντέλο η σειρά των πεδίων σε έναν πίνακα δεν παίζειρόλο
στηνSQLπαίζει. Η καταχώρηση εγγραφής γίνεται βάζοντας τιμές στα πεδία του πίνακαμε τη
σειρά με την οποία ορίστηκαν.

Αν επιθυμούμε να καταχωρήσουμε μια εγγραφή χρησιμοποιώντας τις default τιμές σε
κάποια πεδία αναγράφουμε στο αντίστοιχο πεδίο DEFAULT. Η επιλογή αυτή είναι ιδιαίτερα
χρήσιμηγια την καταχώρηση τιμών σε πεδία AUTO_INCREMENT. Γιαπαράδειγμαηεντολή:

INSERT INTO Customer
VALUES(DEFAULT, '175744444', DEFAULT, 'Eleni', 'Kostantinou', DEFAULT);

θα καταχωρήσει μία καινούργια εγγραφή με address ‘Unknown’, dateOfBirth NULL και cid
τηντιμή του AUTO_INCREMENT.

Μπορούμε να επιλέξουμε τα πεδία στα οποία θα καταχωρηθούν τιμές, ενώ σταυπόλοιπα
πεδία καταχωρείται η default τιμή. Έτσι η προηγούμενη εγγραφή θα μπορούσε να είχε
εισαχθείκαιωςεξής:

INSERT INTO Customer (afm, name, sname)VALUES ('175744444', 'Eleni', 'Kostantinou');


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
**Ενημέρωση εγγραφών(UPDATE...SET...WHERE...)**

Η ενημέρωση εγγραφών, δηλ. η αλλαγή τιμών σε ένα ή περισσότερα πεδία τους, γίνεται με
τηχρήση της εντολής UPDATE. Η βασική σύνταξη της εντολής έχει ως εξής:

```
UPDATEπίνακες
SET λίστα_αναθέσεων
WHERE λογική_έκφραση
```
Το όρισμα στο UPDATE (πίνακες) μπορεί να περιλαμβάνει συνενώσειςπολλαπλών πινάκων,
πίνακες που προκύπτουν από εμφωλευμένα ερωτήματα κλπ. Κατά τηνεκτέλεση, όλες οι
εγγραφές που ανήκουν σε κάποιον από τουςπίνακες που αναγράφονται στοόρισμα πίνακες
του UPDATE και μπορεί να ενημερωθούν ενημερώνονται εφόσον πληρούν τη λογική
συνθήκη του WHERE. Οι αλλαγές στις οποίες υπόκεινται περιγράφονται στο SET.
Ακολουθούνπαραδείγματα.

**_Ερώτημα 1:_** _Τοκίστε με 1% όλους τους λογαριασμούς._

Θα πρέπει στον πίνακα Account να αλλάξουμε το περιεχόμενο του balance.

_UPDATE Account
SET balance=balance+0.01*balance;_

Προσέξτε ότι παραλείποντας το WHERE υπονοείται WHERE TRUE και επομένως το SET
εφαρμόζεται σε όλες τις εγγραφές του Account. Επίσης παρατηρήστε ότι ο τελεστής ‘=’ στο
SET παίζει το ρόλο της ανάθεσης και όχι της σύγκρισης.

**_Ερώτημα 2:_** _Εφαρμόστε έκτακτη εισφορά 500 ευρώ για τους λογαριασμούς με υπόλοιπο άνω
των 30000._

UPDATE Account
SET balance=balance- 500
WHERE balance>30000;

**_Ερώτημα3:_** _Αλλάξτετοον/μοτης:MariaPapantoniouσεMaryPapadoniou._

UPDATE Customer
SET name='Mary', sname='Papadoniou'
WHERE name='Maria' AND sname='Papantoniou';

**_Ερώτημα 4:_** _Αλλάξτε το όνομα του: Kostas Kostantinou σε CostasKostantinou και προσθέστε
1000 ευρώ σε κάθε λογαριασμό του._

1 οςΤρόπος:

Μπορούμε να δούμε το παραπάνω ερώτημα σαν δύο ξεχωριστά ερωτήματα ενημέρωσης.
Πρώτα να ενημερώσουμε το όνομα και στη συνέχεια να ενημερώσουμε το υπόλοιπο
κάνοντας χρήση εμφωλευμένου ερωτήματος (εκτός ύλης,η απάντηση δίνεται ενδεικτικά).


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
UPDATE Customer SET name='Costas' WHERE name='Kostas' AND sname='Kostantinou';

UPDATE Account SET balance=balance+1000 WHERE accid IN (SELECT accid FROM Owns
INNER JOIN Customer ONowns.cid=Customer.cidWHERE name='Costas' AND
sname='Kostantinou');

2 οςΤρόπος:

Μπορούμε να χρησιμοποιήσουμε ένα ερώτημα ενημέρωσης με πολλούς πίνακες όπως
παρακάτω:

UPDATE Customer, Owns, Account
SET name='Costas', balance=balance+
WHERE name='Kostas' AND sname='Kostantinou' AND Customer.cid=Owns.cid AND
Owns.accid=Account.accid;

Ο τρόπος με τον οποίο εκτελείται ένα ερώτημα ενημέρωσης πολλαπλών πινάκων είναι ο
ακόλουθος.

1. Πρώτα υπολογίζεται ο τελικός πίνακας στοUPDATE. Στο παράδειγμα τοκαρτεσιανό
    γινόμενο (ήinnerjoin) τωνCustomer,OwnsκαιAccount.
2. Για κάθε μία εγγραφήτου τελικού πίνακα τουUPDATEπου πληροί τη συνθήκη του
    WHEREγίνονται οι αλλαγές πουπεριγράφονται στοSETστις εγγραφές των αντίστοιχων
    πινάκων από τις οποίες προέκυψε ηεγγραφή που εξετάζεται.

_Προσοχή: Σε ερώτημα ενημέρωσης πολλαπλών πινάκων κάθε εγγραφή ενημερώνεται μία και
μόνο φορά και όχι κάθε φορά που βρίσκεται σε συνδυασμό που πληροί τοWHERE._

Αν και στο UPDATEμπορούμε να έχουμε πίνακες πουπροκύπτουν από εμφωλευμένα
ερωτήματα, δεν μπορούμε να αλλάξουμε τις εγγραφές αυτώντων πινάκων. Γιαπαράδειγμα
τοακόλουθοερώτημα:

UPDATE (SELECT * FROM Customer) C
SET name='Helen' WHEREname= 'Eleni';

θα επιστρέψει το ακόλουθο σφάλμα:
ERROR 1288 (HY000): The target table C of the UPDATE is not updatable

Αντίθετα το ακόλουθο ερώτημα:

UPDATE (SELECT * FROM Customer) C, Customer
SET Customer.name='Helen'
WHERE Customer.name= 'Eleni';

θα πραγματοποιήσει ορθά την αλλαγή ονόματος καθώς τα πεδία που αλλάζουν ανήκουν σε
βασικό πίνακα της ΒΔ και όχι στον πίνακαCπου προέκυψε από το εμφωλευμένο ερώτημα.


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
Τέλος,θα πρέπει να τονιστεί ότι η ενημέρωση πεδίου που είναι ξένο κλειδίαπαγορεύεται σε
περίπτωση που η τιμή στην οποία αλλάζει δεν υπάρχει στον πίνακα στον οποίοαναφέρεται.
Για παράδειγμα η ακόλουθη εντολή:

UPDATEOwns
SETcid=
WHEREcid=1;

οδηγεί σε σφάλμαανδεν υπάρχει στον πίνακαCustomerπελάτης μεcid=100, ενώ θα
εκτελεστεί κανονικάανυπάρχει πελάτης στοCustomerμεαυτό τοcid. Ο πίνακαςCustomer
προφανώς δεθα υποστεί αλλαγές ενώ οOwnsθααλλάξει ώστε όλες οι εγγραφές που είχαν
στοcidτην τιμή 1 να έχουν πλέον την τιμή 100.

Κατ’ αντιστοιχία αν επιχειρηθεί αλλαγή πεδίου σε έναν πίνακα που είναι πίνακας στον οποίο
αναφέρεται ξένο κλειδί άλλου πίνακα θα ισχύσουν οι περιορισμοί αναφοράς που έχουν
τεθεί.

**Διαγραφή εγγραφών (DELETEFROM)**

Η διαγραφή εγγραφών γίνεται με τη χρήση της εντολής DELETE της οποίας η βασική σύνταξη
για έναν πίνακα έχει ως εξής:

DELETE FROM πίνακας

WHERE λογική_έκφραση

Η εκτέλεση τηςεντολής γίνεται εκτιμώντας για κάθε εγγραφή του πίνακα στο DELETE FROM
(πίνακας) τη λογική_έκφραση του WHERE. Αν είναι TRUE τότε η εγγραφή διαγράφεται.

Γιαπαράδειγμα η ακόλουθη εντολή:

DELETE FROM Account;

σβήνει όλες τις εγγραφές του πίνακα Account, καθώς σε περίπτωση που δεν υπάρχει WHERE
υπονοείται WHERE TRUE, ενώ η εντολή:

DELETE FROM Account WHERE balance > 20000;

θα διαγράψει μόνο τις εγγραφές με υπόλοιπο άνω των 20000.

Η DELETE μπορεί να χρησιμοποιηθεί για να διαγραφούν εγγραφές από περισσότερουςτου
ενόςπίνακες. Η βασική σύνταξη σε αυτήν την περίπτωση έχει ως εξής:

DELETE λίστα

FROM πίνακες

WHERE λογική_έκφραση


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
όπου λίστα είναι ένας ή περισσότεροι πίνακες χωρισμένοι με κόμμα και το όρισμα του FROM
(πίνακες) είναι όμοιο με το όρισμα του UPDATEστην εντολή UPDATE-SET-WHERE, δηλ.
περιλαμβάνει έκφραση που ενέχει συνενώσεις πινάκων. Η εκτέλεση της εντολής έχει ως εξής:

1. πρώτα υπολογίζεται το FROM.
2. Στη συνέχεια για κάθε μία από τις εγγραφές του πίνακα πουπαράγεται ελέγχεται αν
    πληρείται η λογική_έκφραση του WHERE.
3. Για τις εγγραφές πουπληρείται διαγράφονται οι αντίστοιχες εγγραφές των πινάκων από
    τις οποίες προέκυψαν. Η διαγραφή γίνεταιμόνογια τους πίνακες που αναγράφονται
    στο όρισμα του DELETE (λίστα) και εφ’ όσον αυτό είναιεπιτρεπτό πχ. δεν πρόκειται για
    πίνακες που προκύπτουν από υποερωτήματα.

**_Παράδειγμα 1:_** _Να διαγραφούν όλοι οι πελάτες από τον πίνακα Customer που δεν έχουν
κάποιολογαριασμό._

DELETE Customer
FROM Customer LEFT JOIN Owns ON Customer.cid=Owns.cid
WHERE Owns.cid IS NULL;

**Ερωτήματα προς τη ΒΔ(SELECT...FROM...WHERE...)**

Έχοντας δημιουργήσει μία ΒΔ μπορούμε να θέσουμε ερωτήματα (queries) για να
ανακτήσουμεεκείνο το μέρος της αποθηκευμένης πληροφορίας που μας ενδιαφέρει κάθε
φορά. Η βασικήδομή ενός SQL ερωτήματος είναι η ακόλουθη:

SELECT πεδία

FROM πίνακες

WHERE λογική_συνθήκη

Οιλογικοί τελεστέςπου υποστηρίζονται είναι οι γνωστοί μας από την άλγεβρα Βool και τις
γλώσσες προγραμματισμού και έχουν ως εξής:

**OR ή ||** :Λογικό Ή

**XOR** : Αποκλειστικό Ή

**AND ή &&** : Λογικό ΚΑΙ

**ΝΟΤ ή!** : Λογική άρνηση

Οιτελεστές σύγκρισηςείναι οι: **<** , **>** , **<=** , **>=** , **=** , **<>** , **!=** ,με τους δύο τελευταίους να είναιίδιοι
(υλοποιούν το διάφορο).

Οιαριθμητικές πράξειςπου υποστηρίζονται είναι οι: **+** , **-** , ***** , **/** , **DIV** , **MOD** , **%,** με το DIVνα είναι
η ακέραια διαίρεση και ταMOD και % το υπόλοιπο της διαίρεσης ακεραίων.

Η MySQL υποστηρίζειεπιπλέον τελεστέςγια χειρισμό τύπων και συγκρίσεις.

```
 IS και IS NOT :Ελέγχει την Boolean τιμή μιας έκφρασης. ΟιBooleanτιμέςείναι: TRUE,
FALSE, UNKNOWN.
 ISNULL και ISNOTNULL :Ελέγχει ανμία έκφραση είναι NULL ή όχι.
```

```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
```
 ΒΕΤWEEN τιμή 1 AND τιμή 2 :Ελέγχει αν μία έκφραση είναι μεγαλύτερη ίση από τιμή1 και
μικρότερη ίση από τιμή2.
 LIKE και NOTLIKE :Ελέγχει αν ένα όρισμα ταιριάζει με κάποιο αλφαριθμητικό πρότυπο.
Η σύγκριση γίνεται χαρακτήρα, χαρακτήρα και επομένως τα κενά στο τέλος παίζουν
ρόλο.Στο πρότυπο μπορούν να χρησιμοποιηθούν τα εξής δύο wildcards: ο χαρακτήρας
_ πουσημαίνει οποιοσδήποτε χαρακτήρας και ο χαρακτήρας % που σημαίνει
οποιαδήποτε σειράχαρακτήρων.
```
Υποστηρίζεται,επίσης,μία πληθώρα τελεστών και συναρτήσεων όσον αφορά στοχειρισμό
αλφαριθμητικών. Στη συνέχεια συνοψίζονται κάποιες από αυτές.

```
 CHAR_LENGTH (αλφαριθμητικό)
Επιστρέφει το πλήθος των χαρακτήρων τουαλφαριθμητικού.
Παράδειγμα:
SELECT CHAR_LENGTH('MySQL5.7');Δίνει8.
 UPPER (αλφαριθμητικό).
Μετατροπή σε κεφαλαία.
Παράδειγμα:
SELECTUPPER('MySql5.7');ΔίνειMYSQL5.7.
 LOWER (αλφαριθμητικό).
Μετατροπή σε πεζά.
Παράδειγμα:
SELECTLOWER('MySql5.7');Δίνειmysql5.7.
 CONCAT (α1, α2, ..).
Συνενώνει τα αλφαριθμητικά α1,α2, κλπ.
Παράδειγμα:
SELECT CONCAT('My', 'SQL5.7'); Δίνει MySQL5.7.
 REPLACE (a1,a2,a3).
Επιστρέφει το α1 μόνο που όπου υπάρχει το α2 αντικαθίσταται μετο α3.
Παράδειγμα:
SELECT REPLACE('MyQL5.7', 'QL', 'SQL');ΔίνειMySQL5.7.
 LOCATE (a1,a2).
Επιστρέφειτη θέση μέσα στο α2 όπου εμφανίζεται το α1 για πρώτηφορά.
Παράδειγμα:
SELECT LOCATE('work', 'The working place where I work'); Δίνει 5.
 SUBSTR ή SUBSTRING (αλφαριθμητικό, θέση, μέγεθος).
Επιστρέφει από το αλφαριθμητικό το υποαλφαριθμητικό που ξεκινά από την
προσδιοριζόμενη θέση και είναι μήκους ίσο με τομέγεθος που δίνεται. Αν δε δίνεται το
μέγεθος επιστρέφεται το υποαλφαριθμητικό από τη θέση και μέχρι το τέλος του
αλφαριθμητικού.
Παράδειγμα:
SELECT SUBSTR('The working place where I work', 5, 4); Δίνει work
```

```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
Πολύ σημαντική είναι η υποστήριξημιαςπληθώραςσυναρτήσεων γιαχειρισμό ημερομηνιών
και χρόνου. Στη συνέχεια συνοψίζονται κάποιες από αυτές.

```
 NOW(),CURRENT_TIMESTAMP()
ΗNOW() επιστρέφει την τρέχουσα ημ/νία και ώρα (τύποςDATETIME). Ισοδύναμη με τη
NOW()είναιηCURRENT_TIMESTAMP.Ως όρισμα στις συναρτήσεις αυτές μπορούμε να
περάσουμε την επιθυμητή ακρίβεια ως υποδιαίρεση του δευτερολέπτου. Η μέγιστη
δυνατήακρίβεια είναι της τάξης του μsecκαι ως εκ τούτου μέγιστη τιμή στο όρισμα
μπορεί να είναιτο 6. Αν δεν προσδιοριστεί η επιθυμητή ακρίβεια υπονοείται 0 δηλ.
ακρίβειαδευτερολέπτου.
Παράδειγμα:
SELECTNOW(6);Δίνειπχ. 2015- 10 - 14 09:27:05.913871.
 DATE(), TIME(), DAY() ή DAYOFMONTH(), DAYOFYEAR(), DAYOFWEEK(),MONTH(),
WEEK(), YEAR(), HOUR(), MINUTE(), SECOND(), MICROSECOND()
Από έναν τύπο DATE ή DATETIME ή TIMESTAMP, εξάγει την πληροφορία που
περιγράφεταιαπό το όνομα της συνάρτησης.
Παράδειγμα:
SELECTMINUTE(NOW()); Αν ηNOW() επέστρεφε τοTIMESTAMPτου προηγούμενου
παραδείγματος δηλ. 2015- 10 - 14 09:27:05 η εντολή θα επέστρεφε 27.
SELECTDATE(NOW()); Στο παράδειγμα επιστρέφει: 2015- 10 - 14.
SELECTTIME(NOW()); Στο παράδειγμα επιστρέφει: 09:27:05.
SELECTDAYOFMONTH(NOW()),DAYOFYEAR(NOW()),DAYOFWEEK(NOW());Στο
παράδειγμα επιστρέφει μία εγγραφή με τρία πεδία: 14, 287, 4.
 DAYNAME(),MONTHNAME()
Επιστρέφουν το όνομα της ημέρας και του μήνααντίστοιχα.
Παράδειγμα:
SELECTDAYNAME('2015- 10 - 14 09:27:05'),MONTHNAME('2015- 10 - 14 09:27:05');
Επιστρέφειμία εγγραφή με δύο πεδία:Wednesday,October.
```
```
 ADDDATE (όρισμα,INTERVALτιμή τύπος).
Προσθέτει στο όρισμα το χρόνο πουκαθορίζεται από την τιμή και τον τύπο της τιμής.
Επιτρεπτοί τύποι τιμών είναι όλες οιυποδιαιρέσεις χρόνου στο εύρος απόYEARμέχρι
MICROSECOND καθώς και συνδυασμοί των DAY, HOUR, MINUTE, SECOND,
MICROSECOND, ανά δύο με πρώτη τημεγαλύτερη μονάδα μέτρηση πχ.DAY_HOUR,
DAY_MINUTEκλπ. Επίσης υποστηρίζεταικαι τοYEAR_MONTH. Τέλος μπορούμε να
παραλείψουμε τον τύπο και τη λέξηINTERVALστην οποία περίπτωση προστίθενται
ημέρες.
Παράδειγμα:
SELECT ADDDATE('2015- 10 - 14', INTERVAL '2-3' YEAR_MONTH);Επιστρέφει: 2018- 01 - 14
SELECTADDDATE('2015- 10 - 14 09:27:05.913871', 10);Επιστρέφει: 2015- 10 - 24
09:27:05.913871.
```
```
 ADDTIME (όρισμα, διάστημα).
Προσθέτει στο όρισμα το χρονικό διάστημα.
```

```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
```
Παράδειγμα:
SELECTADDTIME('2015- 10 - 14 09:27:05.999999', '0.000001');Δίνει 2015 - 10 - 14
09:27:06.
SELECT ADDTIME('2015- 10 - 14 09:27:05.999999', '1 0:1:2.000001'); Δίνει 2015- 10 - 15
09:28:08.
SELECT ADDTIME('2015- 10 - 14 09:27:05.9', '48:0:0'); Δίνει 2015- 10 - 16 09:27:05.900000.
```
```
 TIMESTAMPADD (τύπος, τιμή, όρισμα).
Όμοια με τηνADDDATEμόνο που δενυποστηρίζει ζευγάρια τύπων και η τιμή είναι
αριθμός.
Παράδειγμα:
SELECT TIMESTAMPADD(SECOND, 1.5, '2015- 10 - 14 09:27:05.913871');Επιστρέφει:
2015 - 10 - 14 09:27:07.413871.
```
```
 SUBDATE(),SUBTIME()
Συμμετρικές τωνADDDATE() καιADDTIME() μόνο πουαφαιρούν χρόνο.
```
```
 DATEDIFF (όρισμα1, όρισμα2)
Επιστρέφει τη διαφορά σε ημέρες των δύο ορισμάτων(όρισμα1–όρισμα2).
Παράδειγμα:
SELECTDATEDIFF(ADDTIME('2015- 10 - 14 09:27:05.913871', '1 20:0:0'), '2015- 10 - 14
09:27:05.913871');Επιστρέφει2.
```
**Συναρτήσεις συνάθροισης**
Όλες οι συναρτήσεις συνάθροισης χρησιμοποιούνται στο SELECT τμήμα ενός ερωτήματος.
Παίρνουν ως όρισμα μία έκφρασηκαι επιστρέφουν ως αποτέλεσμα μία τιμή. Η τιμή αυτή
υπολογίζεται ως εξής: υπολογίζεται πρώτα η τιμή της έκφρασης για κάθε γραμμή του πίνακα
και στη συνέχεια εφαρμόζεται η συνάρτηση που περιγράφεται για το σύνολο των τιμών που
υπολογίστηκαν. Αν σε κάποια γραμμή η έκφραση αποτιμείται σε NULL, η συγκεκριμένη
γραμμή δε μετέχει στον υπολογισμό.

Οι βασικές συναρτήσεις συνάθροισης αριθμητικών τιμών στην SQL είναι οι εξής:
 SUM(έκφραση): επιστρέφει το άθροισμα.
 AVG(έκφραση): επιστρέφει το μέσο όρο.
 MAX(έκφραση): επιστρέφει τη μέγιστη τιμή.
 MIN(έκφραση): επιστρέφει την ελάχιστη τιμή.
 STDDEV_POP(έκφραση): επιστρέφει την τυπική απόκλιση.
 COUNT(έκφραση): επιστρέφει το πλήθος γραμμών.

Παράδειγμα:
_Βρες το πλήθος των εγγραφών στον Customer για τις οποίες υπάρχουν διευθύνσεις._
SELECT COUNT(address) FROM Customer;

Επιστρέφει: 3.


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
**Απόκρυψη διπλότυπων εγγραφών (Distinct)**
ΣτοSELECTενός ερωτήματος επιλέγουμε ένα ή περισσότερα πεδία για ναεμφανιστούν. Αν
και σε πίνακες που έχει οριστείPRIMARYKEYδεν υπάρχει περίπτωση ναυπάρξουν δύο ίδιες
εγγραφές, εντούτοις στα αποτελέσματα των ερωτημάτων μπορεί να έχωδιπλές εγγραφές.
Αν αυτό δεν είναι επιθυμητό τότε μπορούμε να χρησιμοποιήσουμε την επιλογή **DISTINCT**.

SELECT name, snameFROM Customer;

Αν υπάρχουν δύο πελάτες με το ίδιο ον/μο επιστρέφεται μία εγγραφή για τον καθένα.

SELECT DISTINCT name, snameFROM Customer;

Οι διπλές εγγραφές κόβονται από το αποτέλεσμα.

**Μετονομασία πεδίου (AS)**
Κάποιες φορές επιθυμούμε να αλλάξουμε το όνομα ενός πεδίου όπως αυτό εμφανίζεταιστο
αποτέλεσμα ενός ερωτήματος. Μπορεί να επιτευχθεί αυτό βάζοντας μετά το πεδίο: **AS
καινούργιο_όνομα**.

SELECT cid, CONCAT(name,' ', surname)FROMCustomer;

Εμφανίζει έναν πίνακα με τις εξής δύο στήλες:cidκαιCONCAT(name,' ',surname).

SELECTcid, CONCAT(name,' ', surname) AS fullNameFROMCustomer;

Εμφανίζει τα ίδια αποτελέσματα με πριν σε έναν πίνακα με τις εξής δύο στήλες:cidκαι
fullName.

**Ταξινόμηση (Order By)**
Ανδώσουμετοερώτημα:

SELECT name, cid, snameFROM Customer;

θα δούμε ότι τα αποτελέσματα επιστρέφονται σε αύξουσα σειρά ως προς cid. Γενικά
μιλώνταςτα αποτελέσματα ενός ερωτήματος επιστρέφονται σε αύξουσα σειρά ως προς το
PRIMARYKEY. Αν επιθυμούμε να επιστρέψουμε τα αποτελέσματα με άλλη σειρά μπορούμε
να τοκάνουμε προσθέτοντας στο τέλος του ερωτήματος την επιλογή **ORDER BY**.

SELECT *FROM CustomerWHERE TRUEORDER BY sname ASC, dateOfBirth DESC;

Το ερώτημα θα εμφανίσει όλες τις εγγραφές του πίνακαCustomerταξινομημένες πρώτα ως
προς αύξουσα σειρά επωνύμου (ASCαπό τοascending) και έπειτα (για τις εγγραφές με ίδιο
επώνυμο) ταξινομημένες ως προς ημ/νια γέννησης σε φθίνουσα σειρά (DESCαπό το
descending). Αν παραλείψουμε τους προσδιοριστέςASC/DESCτοdefaultείναι τοASC.

**Επιλογή όλων (*)**
Αν επιθυμούμε να εμφανίσουμε όλα τα πεδία του πίνακα που προκύπτει από τοFROM,αντί
να τα αναφέρουμε στοSELECTένα προς ένα, μπορούμε να χρησιμοποιήσουμε το *****.

Παράδειγμα:
SELECT*FROMCustomer;

Ισοδύναμομετο:

SELECT cid, afm, address, name, sname, dateOfBirthFROMCustomer;


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
**Βασικές πράξεις συνόλων**

Έστω ότι έχουμε δύο σύνολα τα R και S που έχουν ιδίου τύπου στοιχεία. Θεωρείστε την
παρακάτω αναπαράσταση των συνόλων R και S(σε μορφή διαγραμμάτων Venn).

**Ένωση συνόλων** :Η πράξη της ένωσης συμβολίζεται με το U. Το αποτέλεσμά της R U S είναι
ένα νέο σύνολο που περιέχει τόσο τα στοιχεία του R όσο και του S. Στο διάγραμμα Venn είναι
όλη η χρωματισμένη περιοχή ανεξαρτήτως χρώματος.

**Τομή συνόλων** :Η πράξη της τομής συμβολίζεται με το∩.Το αποτέλεσμά της R∩ Sείναι ένα
νέο σύνολο που περιέχει τα στοιχεία του R που είναι και στοιχεία του S, δηλ. τα κοινά
στοιχείατων δύο συνόλων. Στο διάγραμμα Venn είναι η χρωματισμένη με πορτοκαλί
περιοχή.

**Διαφορά συνόλων** :Η πράξη της διαφοράς συμβολίζεται με το-. Το αποτέλεσμά της R-S
είναιένα νέο σύνολο που περιέχει τα στοιχεία του R που δεν είναι στοιχεία του S, δηλ. τα
στοιχεία του R που δεν ανήκουν στην τομή με το S. Στο διάγραμμα Venn είναι η
χρωματισμένη μεκίτρινο περιοχή, ενώ η χρωματισμένη με κόκκινο αντιστοιχεί στο S-R.

Θεωρώντας τους πίνακες μιας σχεσιακής ΒΔ ως σύνολα εγγραφών, οι παραπάνω πράξεις
βρίσκουν εφαρμογή κυρίως όποτε θέλουμε να συνδυάσουμε αποτελέσματα ερωτημάτων. Η
υλοποίησή τους στην SQL γίνεται μέσω των εντολών UNION, INTERSECT και EXCEPT ή MINUS.
Η γενικότερη μορφή σύνταξης είναι:

```
ερώτημα 1
UNION/INTERSECT/EXCEPT
```
```
ερώτημα 2
```
Παράδειγμα
_Βρες τους κωδικούς των πελατών που έχουν κινητό τηλέφωνο ή το όνομά τους είναι Maria._

Το ερώτημα εμπλέκει 2 πίνακες. Στην ουσία θέλουμε τα αποτελέσματα από 2 ερωτήματα
αλλά θέλουμε να ισχύει τουλάχιστον μία από τις δύο συνθήκες, πράγμα που σημαίνει ότι
θέλουμε την ένωση των 2 ερωτημάτων. Για οπτικούς λόγους βάζουμε τα δύο υποερωτήματα
μέσασεπαρενθέσειςγια να συμπτύξουμε τις γραμμές, αφού κάθε υποερώτημα είναι μικρό:

(SELECT cid FROM Customer WHERE name='Maria')
UNION
(SELECT cid FROM Phones WHERE pnum LIKE '6%');


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
**Προσοχή:** H MySQL στην έκδοση 5.7 δεν υποστηρίζει τις πράξεις INTERSECT καιEXCEPT αλλά
μόνο το UNION.

**Καρτεσιανό γινόμενο**
Δοθέντος δύο συνόλων R και S που δεν έχουν απαραίτητα στοιχεία ιδίου τύπου, το
καρτεσιανό γινόμενο των δύο συνόλων (RXS) ορίζεται σαν το σύνολο που αποτελείται από
όλα τα ζευγάρια της μορφής (a, b) όπου το aανήκει στο R και το b στο S. Με άλλα λόγια είναι
ένα σύνολο που περιέχει όλους τους συνδυασμούς στοιχείων του R με το S.

Το καρτεσιανό γινόμενο είναι η βασική πράξη συνδυασμού δύο η περισσοτέρων πινάκων σε
ένα ερώτημα. Για να εφαρμόσουμε καρτεσιανό γινόμενο δύο πινάκων στο FROM του
αντίστοιχου ερωτήματος μπορούμε ή να γράψουμε τα ονόματα των δύο πινάκων χωρισμένα
με κόμμα ή να χρησιμοποιήσουμε την εντολή CROSS JOIN.

Παράδειγμα
_Εμφάνισε το καρτεσιανό γινόμενο των πινάκων Customer και Phones._

**1 οςτρόπος:** SELECT * FROM Customer, Phones;

**2 οςτρόπος:** SELECT * FROM Customer CROSS JOIN Phones;


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
Παρατηρήστε ότι:
A)Οι εγγραφές του καρτεσιανού γινομένου είναι όλοι οι δυνατοί συνδυασμοί των εγγραφών
των δύο πινάκων. Στη γενικότερη περίπτωση αν έχω στον πρώτο πίνακα Μ εγγραφές και στο
δεύτερο Ν, στο καρτεσιανό θα υπάρχουν ΜΝ εγγραφές. Αυτό σημαίνει ότι ενδέχεται κάποιες
εγγραφές που επιστρέφονται να είναι ίδιες.

B)Τα πεδία του καρτεσιανού γινομένου είναι τα πεδία και των δύο πινάκων. Σε περίπτωση
που υπάρχουν κοινά πεδία στους δύο πίνακες (το cid στο παράδειγμα) εμφανίζονται δύο
φορές στο αποτέλεσμα. Για να χρησιμοποιήσουμε κάποιο κοινό πεδίο στο ερώτημα θα
πρέπει να αναφερθούμε συγκεκριμένα στον πίνακα από τον οποίο προέρχεται, γράφοντας
το όνομα του πίνακα μαζί με του πεδίου χωρισμένα με τελεία.

**Συνένωση**

Η πράξη του καρτεσιανού γινομένου δύο πινάκων Τ1 και Τ2 και ησυνακόλουθη εφαρμογή
κριτηρίων στο WHERE, είναι τόσο συχνή που αναφερόμαστε ξεχωριστά σε αυτή ως
συνένωση-θ (θ-join) των πινάκων Τ1 και Τ2. Θεωρήστε τους ακόλουθους πίνακες Customer
και Phones:

Το παρακάτω ερώτημα:
SELECT afm
FROM Customer, Phones
WHERE Customer.cid=Phones.cid AND Phones.pnum LIKE '6%';

βρίσκει τα ΑΦΜ των πελατών που έχουν κινητά τηλέφωνα. Ο τρόπος σύνταξης του
ερωτήματος υπονοεί ότι πρώτα θα γίνει το καρτεσιανό γινόμενο των δύο πινάκων και στη
συνέχεια θα εφαρμοστούν τα κριτήρια του WHERE. Με άλλα λόγια πρώτα θα δημιουργηθούν
οι 9 εγγραφές του καρτεσιανού και στη συνέχεια θα επιλεγούν αυτές που πληρούν το
WHERE. Αντίθετα η χρήση της συνένωσης-θ στην παραπάνω περίπτωση θα υπονοούσε ότι
δε χρειάζεται να παραχθεί πρώτα το καρτεσιανό γινόμενο αλλά το μέρος αυτού που πληροί
τη συνθήκη Customer.cid=Phones.cid (3 εγγραφές) και στη συνέχεια οι εγγραφές αυτές θα
ελέγχονταν ως προς τη συνθήκη Phones.pnum LIKE '6%'.

Η βασική δομή εντολής για να κάνουμε συνένωση δύο πινάκων είναι:

```
πίνακας1 [INNER | CROSS] JOIN πίνακας2 [join_συνθήκη]
```
όπου στη join_συνθήκη μπορούμε να έχουμε τις ακόλουθες δύο επιλογές:
o ON λογική_συνθήκη: κατά τα πρότυπα του WHERE.
o USING (λίστα_πεδίων): ισότητα στα πεδία της λίστας με την προϋπόθεση να είναι κοινά
και γιατουςδύο πίνακες.


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
Στη MySQL JOIN, INNER JOIN και CROSS JOIN είναι ισοδύναμα και πραγματοποιούν αυτό που
ονομάζεται **εσωτερική συνένωση πινάκων**.

Παραδείγματα
_Οι ακόλουθες queries βρίσκουν τα afm των πελατών που έχουν κινητό τηλέφωνο._

**_(I) Με comma join_**
SELECT afm
FROM Customer, Phones
WHERE Customer.cid=Phones.cid AND Phones.pnum LIKE '6%';

**_(II) Με INNER JOIN._**
SELECT afm
FROM Customer INNER JOIN Phones ON Customer.cid=Phones.cid
WHERE Phones.pnum LIKE '6%';

**_(III) Με JOIN (ισοδύναμο του INNER JOIN)_**
SELECT afm
FROM Customer JOIN Phones ON Customer.cid=Phones.cid
WHERE Phones.pnum LIKE '6%';

**_(IV) Με CROSS JOIN_**
SELECT afm
FROM Customer CROSS JOIN Phones ON Customer.cid=Phones.cid
WHERE Phones.pnum LIKE '6%';

**_(V) INNER JOIN χρησιμοποιώντας το USING αντί του ON._**
SELECT afm
FROM Customer INNER JOIN Phones USING (cid)
WHERE Phones.pnum LIKE '6%';

**_(VI) Ισοδύναμη με την (Ι)_**
SELECT afm
FROM Customer CROSS JOIN Phones
WHERE Customer.cid=Phones.cid AND Phones.pnum LIKE '6%';

**_(VII) INNER JOIN χωρίς WHERE_**
SELECT afm
FROM
Customer INNER JOIN Phones ON
Customer.cid=Phones.cid AND Phones.pnum LIKE '6%';

**Εξωτερικές συνενώσεις**

Ας υποθέσουμε ότι στο Phones δεν είχαμε ορίσει ως ξένο κλειδί το cid και είχαμε το
ακόλουθοστιγμιότυπο για τους πίνακες Customer και Phones:


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
```
Έστω ότι θέλουμε να εμφανίσουμε τα στοιχεία των πελατών μαζί με τα τηλέφωνά τους (αν
έχουν). Το ερώτημα δεν μπορεί να απαντηθεί χρησιμοποιώντας εσωτερική συνένωση καθώς
με αυτό τον τρόπο δε θα επιστραφούν τα στοιχεία του πελάτη με cid=3 καθώς δε
συνδυάζεται με καμία από τις εγγραφές στοPhones. Κάτι αντίστοιχο θα προέκυπτε εάν
ζητούσαμε τα τηλέφωνα μαζί με στοιχεία για τους πελάτες που ανήκουν (αν υπάρχουν
ιδιοκτήτες). Για να απαντηθούν τέτοια ερωτήματα χρησιμοποιούνται εξωτερικές
συνενώσεις. ΣτηνSQLπεριγράφονται τριών ειδών εξωτερικές συνενώσεις: αριστερή (LEFT),
δεξιά (RIGHT) και πλήρης (FULL). Η σύνταξη είναι αντίστοιχη της εσωτερικής συνένωσης:
```
```
πίνακας1 {LEFT | RIGHT | FULL} [OUTER] JOIN πίνακας2 join_συνθήκη
Η αναγραφή τουOUTERείναι προαιρετική και στην πράξη πολλές φορές παραλείπεται.
Οι κανόνες για ταONκαιUSINGόσον αφορά τις επιστρεφόμενες στήλες είναι.
```
```
Παραδείγματα
LEFT JOIN
i. SELECT * FROM Customer LEFT JOIN Phones ON Customer.cid=Phones.cid;
Επιστρέφει:
```
```
Όπως παρατηρούμε η εγγραφή με cid=3 του πίνακα Customer που δε συνδυάζεται με καμία
εγγραφή από τον πίνακα Phones βρίσκεται στο αποτέλεσμα του LEFT JOIN, με NULL στα
πεδία του Phones.
```
**ii.** SELECT * FROM Customer LEFT JOIN Phones USING(cid);
Επιστρέφει:


```
6ο Εσπερινό ΕΠΑΛ Θεσσαλονίκης Τομέας Πληροφορικής ΤάξηΓ'
```
## RIGHTJOIN

```
i. SELECT *FROM Customer RIGHT JOIN Phones ON Customer.cid=Phones.cid;
Επιστρέφει:
```
```
ii. SELECT *FROM Customer RIGHT JOIN Phones USING(cid);
Επιστρέφει:
```
## FULL JOIN

```
i. SELECT *FROM Customer FULL JOIN Phones ON Customer.cid=Phones.cid;
Επιστρέφει:
```
```
Παρατηρούμε ότι τόσο οι εγγραφές του Customer που δε συνδυάζονται, όσο και οι
αντίστοιχεςεγγραφές του Phones εμφανίζονται στο αποτέλεσμα με NULL στα πεδία του
άλλου πίνακα.
```
**ii.** SELECT *FROM Customer FULL JOIN Phones USING(cid);
Επιστρέφει:



